(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{367:function(t,v,_){"use strict";_.r(v);var a=_(43),r=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"http1-x-版本问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http1-x-版本问题"}},[t._v("#")]),t._v(" http1.x 版本问题")]),t._v(" "),_("ul",[_("li",[t._v("在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。")]),t._v(" "),_("li",[t._v("HTTP/1.1 版本默认允许复用 TCP 连接，但是在同一个 TCP 连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成队头阻塞。")])]),t._v(" "),_("ul",[_("li",[t._v("http/1.x 版本支持 Keep-alive，用此方案来弥补创建多次连接产生的延迟，但是同样会给服务器带来压力，并且的话，对于单文件被不断请求的服务，Keep-alive 会极大影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。")])]),t._v(" "),_("h2",{attrs:{id:"http2-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http2-0"}},[t._v("#")]),t._v(" http2.0")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("二进制分帧")]),t._v(' 这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"：头信息帧和数据帧。')])]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("头部压缩")]),t._v(" HTTP 1.1 版本会出现 「User-Agent、Cookie、Accept、Server、Range」 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 HPACK 算法进行压缩。")]),t._v(" "),_("li",[_("strong",[t._v("多路复用")]),t._v(" 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。")]),t._v(" "),_("li",[_("strong",[t._v("服务器推送")]),t._v(" 允许服务器未经请求，主动向客户端发送资源，即服务器推送。")]),t._v(" "),_("li",[_("strong",[t._v("请求优先级")]),t._v(" 可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。")])]),t._v(" "),_("h2",{attrs:{id:"头部压缩"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#头部压缩"}},[t._v("#")]),t._v(" 头部压缩")]),t._v(" "),_("img",{attrs:{src:t.$withBase("/imgs/Hpack.png"),alt:"Hpack"}}),t._v(" "),_("ul",[_("li",[t._v("类似于索引表，每个索引表对应一个值，比如索引为 2 对应头部中的 method 头部信息，这样子的话，在传输的时候，不在是传输对应的头部信息了，而是传递索引，对于之前出现过的头部信息，只需要把「索引」(比如 1，2，...)传给对方即可，对方拿到索引查表就行了。")])]),t._v(" "),_("p",[t._v("简单来说，头部压缩需要在支持 HTTP/2 的浏览器和服务端之间：")]),t._v(" "),_("ul",[_("li",[t._v("维护一份相同的静态字典（Static Table），包含常见的头部名称，以及特别常见的头部名称与值的组合；")])]),t._v(" "),_("ul",[_("li",[_("p",[t._v("维护一份相同的动态字典（Dynamic Table），可以动态地添加内容；")])]),t._v(" "),_("li",[_("p",[t._v("支持基于静态哈夫曼码表的哈夫曼编码（Huffman Coding）；")]),t._v(" "),_("p",[t._v("1.静态字典的作用主要是对于完全匹配的头部键值对，直接使用一个字符来表示。"),_("br"),t._v("\n2.浏览器也可以告知服务端，将键值对添加到动态字典中，这样后续整个键值对就可以使用一个字符表示了。"),_("br"),t._v("\n3.静态字典在首次请求中就可以使用。对于静态、动态字典中不存在的内容，还可以使用哈夫曼编码来减小体积。"),_("br"),t._v("\n4.哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的「索引序列」，可以达到非常高的压缩率")])])]),t._v(" "),_("h2",{attrs:{id:"多路复用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多路复用"}},[t._v("#")]),t._v(" 多路复用")]),t._v(" "),_("p",[t._v("为什么 HTTP/1.1 不能实现“多路复用”？")]),t._v(" "),_("p",[t._v("HTTP/2 是基于二进制“帧”的协议，HTTP/1.1 是基于“文本分割”解析的协议。")]),t._v(" "),_("h3",{attrs:{id:"帧和流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#帧和流"}},[t._v("#")]),t._v(" 帧和流")]),t._v(" "),_("p",[t._v("帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。")]),t._v(" "),_("ul",[_("li",[t._v("报文格式就被拆分为一个个二进制帧，用「Headers 帧」存放头部字段，「Data 帧」存放请求体数据。这样子的话，就是一堆乱序的二进制帧，它们不存在先后关系，因此不需要排队等待，解决了 HTTP 队头阻塞问题。")])]),t._v(" "),_("ul",[_("li",[t._v("在客户端与服务器之间，双方都可以互相发送二进制帧，这样子「双向传输的序列」，称为流，所以 HTTP/2 中以流来表示一个 TCP 连接上进行多个数据帧的通信----多路复用。")])]),t._v(" "),_("p",[t._v("乱序的二进制帧，如何组装成对于的报文呢？")]),t._v(" "),_("ul",[_("li",[t._v("所谓的乱序，值的是不同 ID 的 Stream 是乱序的，对于同一个 Stream ID 的帧是按顺序传输的。")]),t._v(" "),_("li",[t._v("接收方收到二进制帧后，将相同的 Stream ID 组装成完整的请求报文和响应报文。")])]),t._v(" "),_("ul",[_("li",[t._v("二进制帧中有一些字段，控制着"),_("code",[t._v("优先级")]),t._v("和"),_("code",[t._v("流量控制")]),t._v("等功能，这样子的话，就可以设置数据帧的优先级，让服务器处理重要资源，优化用户体验。")])]),t._v(" "),_("h2",{attrs:{id:"服务器推送"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#服务器推送"}},[t._v("#")]),t._v(" 服务器推送")])])}),[],!1,null,null,null);v.default=r.exports}}]);